import os
import time
import requests
import telebot
import json
import threading
import schedule
from datetime import datetime, timedelta
from pytz import timezone
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# C·∫•u h√¨nh bot Telegram
BOT_TOKEN = os.getenv("BOT_TOKEN")
BASE_URL = 'https://api.binance.com/api/v3'

# T·∫°o bot Telegram
bot = telebot.TeleBot(BOT_TOKEN)
CHECKLIST_FILE = 'checklist.txt'
PREVIOUS_RATIO_FILE = 'previous_ratios.json'
USER_CHAT_ID = None  # Bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u chat_id

def load_previous_ratios():
	if os.path.exists(PREVIOUS_RATIO_FILE):
		with open(PREVIOUS_RATIO_FILE, 'r') as f:
			try:
				ratios = json.load(f)
				return ratios
			except json.JSONDecodeError:
				return {}
	return {}

def save_previous_ratios(ratios):
	with open(PREVIOUS_RATIO_FILE, 'w') as f:
		json.dump(ratios, f)

def read_coin_list():
	if not os.path.exists(CHECKLIST_FILE):
		return []
	
	with open(CHECKLIST_FILE, 'r') as f:
		# L·ªçc b·ªè c√°c d√≤ng tr·ªëng v√† chu·∫©n h√≥a d·ªØ li·ªáu
		coins = [coin.strip().upper() for coin in f.readlines() if coin.strip()]
	
	# Ghi danh s√°ch ƒë√£ lo·∫°i b·ªè d√≤ng tr·ªëng tr·ªü l·∫°i t·ªáp
	with open(CHECKLIST_FILE, 'w') as f:
		for coin in coins:
			f.write(f"{coin}\n")
	
	return coins

def write_coin_list(coins):
	with open(CHECKLIST_FILE, 'w') as f:
		for coin in coins:
			f.write(f"{coin.upper()}\n")

# Th√™m handler ƒë·ªÉ l∆∞u chat_id khi start bot
@bot.message_handler(commands=['start'])
def start_handler(message):
	global USER_CHAT_ID
	USER_CHAT_ID = message.chat.id

	# Th√™m gi·ªù trong th√¥ng b√°o b·∫Øt ƒë·∫ßu
	utc_tz = timezone('UTC')
	current_time_utc = datetime.now(utc_tz).strftime('%H:%M - %d.%m.%y')
	bot.reply_to(message, f"B·∫Øt ƒë·∫ßu theo d√µi coin theo danh s√°ch l√∫c {current_time_utc} UTC.")

	try:
		# ƒê·ªçc danh s√°ch coin hi·ªán t·∫°i t·ª´ checklist.txt
		current_coins = read_coin_list()
		if not current_coins:
			bot.reply_to(message, "Danh s√°ch coin tr·ªëng. Vui l√≤ng th√™m coin b·∫±ng l·ªánh /add.")
			return

		# L·∫•y d·ªØ li·ªáu t·ª∑ l·ªá theo th·ªùi gian th·ª±c
		chunk_start = datetime.now(utc_tz).replace(hour=0, minute=0, second=0, microsecond=0)
		chunk_end = datetime.now(utc_tz)

		previous_ratios = {}  # Kh·ªüi t·∫°o d·ªØ li·ªáu m·ªõi cho previous_ratios
		failed_coins = []  # Danh s√°ch c√°c coin kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu

		for symbol in current_coins:
			try:
				params = {
					'symbol': symbol,
					'interval': '5m',
					'startTime': int(chunk_start.timestamp() * 1000),
					'endTime': int(chunk_end.timestamp() * 1000),
					'limit': 500
				}
				response = requests.get(f"{BASE_URL}/klines", params=params)
				data = response.json()

				if response.status_code != 200 or not data or not isinstance(data, list):
					failed_coins.append(symbol)
					continue

				# T√≠nh t·ª∑ l·ªá cao/th·∫•p (ratio)
				formatted_data = []
				for kline in data:
					low_price = float(kline[3])  # Lowest price
					formatted_data.append(low_price)

				if formatted_data:
					lowest_price = min(formatted_data)
					highest_price = max(formatted_data)
					ratio = highest_price / lowest_price

					# L∆∞u v√†o previous_ratios
					previous_ratios[symbol] = {
						'ratio': ratio, 
						'tracking_time': datetime.now(utc_tz).strftime('%d.%m.%y - %H:%M')
					}
			except Exception as e:
				print(f"L·ªói khi x·ª≠ l√Ω coin {symbol}: {e}")
				failed_coins.append(symbol)

		# L∆∞u d·ªØ li·ªáu m·ªõi v√†o t·ªáp previous_ratios
		save_previous_ratios(previous_ratios)

		# G·ª≠i th√¥ng b√°o v·ªÅ c√°c coin kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu
		if failed_coins:
			response_message = "Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu cho c√°c coin sau:\n" + "\n".join(failed_coins)
			bot.reply_to(message, response_message)

	except Exception as e:
		print(f"L·ªói: {str(e)}")

@bot.message_handler(commands=['status'])
def status_coins(message):
	previous_ratios = load_previous_ratios()
	
	if not previous_ratios:
		bot.reply_to(message, "Ch∆∞a c√≥ d·ªØ li·ªáu theo d√µi coin.")
		return
	
	status_message = "Tracking time:\n\n"
	for symbol, data in previous_ratios.items():
		status_message += f"{symbol}:\n"
		status_message += f"  T·ªâ l·ªá Cao/Th·∫•p: {data['ratio']:.4f}\n"
		status_message += f"  L·∫ßn ghi cu·ªëi: {data.get('tracking_time', 'Kh√¥ng c√≥ d·ªØ li·ªáu')}\n\n"
	
	bot.reply_to(message, status_message)

@bot.message_handler(commands=['add'])
def add_coins(message):
	try:
		# L·∫•y danh s√°ch c√°c coin c·∫ßn th√™m
		coins_to_add = [coin.strip().upper() for coin in message.text.split('/add')[1].replace(',', '\n').split('\n') if coin.strip()]
		current_coins = read_coin_list()
		response_message = ""
		utc_tz = timezone('UTC')
		current_time_utc = datetime.now(utc_tz)

		# X√°c ƒë·ªãnh c√°c coin m·ªõi v√† c√°c coin ƒë√£ t·ªìn t·∫°i
		newly_added = [coin for coin in coins_to_add if coin not in current_coins]
		existing_coins = [coin for coin in coins_to_add if coin in current_coins]

		# N·∫øu c√≥ coin ƒë√£ t·ªìn t·∫°i, th√¥ng b√°o cho ng∆∞·ªùi d√πng
		if existing_coins:
			response_message += "C√°c coin sau ƒë√£ t·ªìn t·∫°i trong danh s√°ch:\n" + "\n".join(existing_coins) + "\n"

		# Th√™m c√°c coin m·ªõi v√†o danh s√°ch
		current_coins += newly_added

		# Ghi danh s√°ch c·∫≠p nh·∫≠t v√†o file
		write_coin_list(current_coins)

		# Ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa c√°c coin m·ªõi
		invalid_coins = []
		chunk_start = current_time_utc.replace(hour=0, minute=0, second=0, microsecond=0)
		chunk_end = current_time_utc

		previous_ratios = load_previous_ratios()

		for symbol in newly_added:
			try:
				params = {
					'symbol': symbol,
					'interval': '5m',
					'startTime': int(chunk_start.timestamp() * 1000),
					'endTime': int(chunk_end.timestamp() * 1000),
					'limit': 500
				}
				response = requests.get(f"{BASE_URL}/klines", params=params)
				data = response.json()

				if response.status_code != 200 or not data or not isinstance(data, list):
					invalid_coins.append(symbol)
					continue

				# T√≠nh t·ª∑ l·ªá cao/th·∫•p
				formatted_data = []
				for kline in data:
					low_price = float(kline[3])  # Lowest price
					formatted_data.append(low_price)

				if formatted_data:
					lowest_price = min(formatted_data)
					highest_price = max(formatted_data)
					ratio = highest_price / lowest_price
					previous_ratios[symbol] = {
						'ratio': ratio, 
						'tracking_time': current_time_utc.strftime('%d.%m.%y - %H:%M')
					}

			except Exception as e:
				print(f"L·ªói khi ki·ªÉm tra coin {symbol}: {e}")
				invalid_coins.append(symbol)

		# L∆∞u l·∫°i previous_ratios n·∫øu c√≥ thay ƒë·ªïi
		save_previous_ratios(previous_ratios)

		# Lo·∫°i b·ªè c√°c coin kh√¥ng h·ª£p l·ªá kh·ªèi file v√† th√¥ng b√°o
		if invalid_coins:
			current_coins = [coin for coin in current_coins if coin not in invalid_coins]
			write_coin_list(current_coins)
			response_message += "C√°c coin sau kh√¥ng h·ª£p l·ªá v√† ƒë√£ b·ªã x√≥a:\n" + "\n".join(invalid_coins)
		else:
			response_message += "ƒê√£ th√™m v√† c·∫≠p nh·∫≠t c√°c coin sau l√∫c " + current_time_utc.strftime('%H:%M - %d.%m.%y') + ":\n" + "\n".join(newly_added)

		bot.reply_to(message, response_message)
	except Exception as e:
		print(f"L·ªói: {str(e)}")

@bot.message_handler(commands=['remove'])
def remove_coins(message):
	try:
		# L·∫•y danh s√°ch c√°c coin c·∫ßn x√≥a
		coins_to_remove = [coin.strip().upper() for coin in message.text.split('/remove')[1].replace(',', '\n').split('\n') if coin.strip()]
		current_coins = read_coin_list()

		# X√°c ƒë·ªãnh c√°c coin th·ª±c s·ª± t·ªìn t·∫°i trong danh s√°ch hi·ªán t·∫°i
		valid_coins_to_remove = [coin for coin in coins_to_remove if coin in current_coins]

		# C·∫≠p nh·∫≠t danh s√°ch coin
		updated_coins = [coin for coin in current_coins if coin not in valid_coins_to_remove]
		write_coin_list(updated_coins)

		# X√≥a c√°c coin h·ª£p l·ªá kh·ªèi previous_ratios
		previous_ratios = load_previous_ratios()
		for coin in valid_coins_to_remove:
			if coin in previous_ratios:
				del previous_ratios[coin]
		save_previous_ratios(previous_ratios)

		# T·∫°o ph·∫£n h·ªìi
		if valid_coins_to_remove:
			response = "ƒê√£ x√≥a c√°c coin sau:\n" + "\n".join(valid_coins_to_remove)
		else:
			response = "Kh√¥ng c√≥ coin n√†o trong danh s√°ch c·∫ßn x√≥a."

		bot.reply_to(message, response)
	except Exception as e:
		bot.reply_to(message, f"L·ªói: {str(e)}")

@bot.message_handler(commands=['list'])
def list_coins(message):
	coins = read_coin_list()
	if coins:
		response = "Danh s√°ch coin hi·ªán t·∫°i:\n" + "\n".join(coins)
	else:
		response = "Danh s√°ch coin tr·ªëng."
	bot.reply_to(message, response)

@bot.message_handler(commands=['help'])
def help_command(message):
	help_text = """
üìã Danh s√°ch c√°c l·ªánh h·ªó tr·ª£:

/start - B·∫Øt ƒë·∫ßu theo d√µi coin v√† l∆∞u chat ID
/help - Hi·ªÉn th·ªã danh s√°ch c√°c l·ªánh h·ªó tr·ª£

Qu·∫£n l√Ω Danh S√°ch Coin:
/add [coin1, coin2, ...] - Th√™m coin v√†o danh s√°ch theo d√µi
	V√≠ d·ª•: /add BTCUSDT, ETHUSDT
	B·∫°n c√≥ th·ªÉ th√™m nhi·ªÅu coin c√πng l√∫c b·∫±ng c√°ch ph√¢n t√°ch b·∫±ng d·∫•u ph·∫©y

/remove [coin1, coin2, ...] - X√≥a coin kh·ªèi danh s√°ch theo d√µi
	V√≠ d·ª•: /remove BTCUSDT, ETHUSDT
	B·∫°n c√≥ th·ªÉ x√≥a nhi·ªÅu coin c√πng l√∫c

/list - Hi·ªÉn th·ªã danh s√°ch coin hi·ªán t·∫°i ƒëang theo d√µi

/status - Hi·ªÉn th·ªã l·∫ßn c·∫≠p nh·∫≠t cu·ªëi trong file t·ªâ l·ªá cao/th·∫•p

ü§ñ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng:
- Th√™m coin v√†o danh s√°ch ƒë·ªÉ bot theo d√µi v√† g·ª≠i th√¥ng b√°o
- M·ªói coin s·∫Ω ƒë∆∞·ª£c ph√¢n t√≠ch gi√° v√† g·ª≠i th√¥ng b√°o t·ª± ƒë·ªông
- S·ª≠ d·ª•ng /help ƒë·ªÉ xem h∆∞·ªõng d·∫´n chi ti·∫øt b·∫•t k·ª≥ l√∫c n√†o
"""
	bot.reply_to(message, help_text)

def check_coin_limits():
	global USER_CHAT_ID
	if USER_CHAT_ID is None:
		return  # Exit if no chat_id

	coins = read_coin_list()
	utc_tz = timezone('UTC')
	current_time_utc = datetime.now(utc_tz)
	chunk_start = current_time_utc.replace(hour=0, minute=0, second=0, microsecond=0)
	chunk_end = current_time_utc

	alert_messages = []  # List to store messages
	previous_ratios = load_previous_ratios()
	current_ratios = {}
	has_significant_increase = False

	for symbol in coins:
		try:
			params = {
				'symbol': symbol,
				'interval': '5m',
				'startTime': int(chunk_start.timestamp() * 1000),
				'endTime': int(chunk_end.timestamp() * 1000),
				'limit': 500
			}
			response = requests.get(f"{BASE_URL}/klines", params=params)
			data = response.json()

			if response.status_code != 200 or not data or not isinstance(data, list):
				continue

			try:
				formatted_data = []
				for kline in data:
					open_time = datetime.fromtimestamp(int(float(kline[0])) / 1000, tz=utc_tz)
					formatted_time = open_time.strftime('%d.%m.%y - %H:%M')
					low_price = float(kline[3])  # Lowest price
					formatted_kline = [formatted_time, low_price]
					formatted_data.append(formatted_kline)

				# Sort by low price and get 2 lowest and 2 highest
				formatted_data.sort(key=lambda x: x[1])
				
				lowest_2 = formatted_data[:2]
				highest_2 = formatted_data[-2:]

				# Calculate limits
				lowest_price = lowest_2[0][1]
				highest_price = highest_2[-1][1]
				
				# Calculate and track ratio
				ratio = highest_price / lowest_price
				current_ratios[symbol] = {
					'ratio': ratio,
					'tracking_time': datetime.now(utc_tz).strftime('%d.%m.%y - %H:%M')
				}
				
				# Create message for this symbol
				alert_message = f"{symbol}:\n"
				
				# Combine and sort by time
				combined_records = sorted(lowest_2 + highest_2, key=lambda x: x[1])
				
				for i, (time, low) in enumerate(combined_records):
					if i == 2:
						alert_message += "  ...\n"
					alert_message += f"  {time} : {low:.8f}\n"

				# Ki·ªÉm tra v√† format ratio
				if symbol not in previous_ratios:
					# N·∫øu symbol ch∆∞a t·ª´ng c√≥ trong previous_ratios
					alert_message += f"\n  T·ªâ l·ªá Cao/Th·∫•p: {ratio:.4f}\n"
					previous_ratios[symbol] = current_ratios[symbol]
				else:
					# N·∫øu symbol ƒë√£ c√≥ trong previous_ratios
					prev_data = previous_ratios[symbol]
					prev_ratio = prev_data['ratio']

					# Determine if the ratio has increased
					is_increased = ratio >= (prev_ratio + 0.01)

					ratio_change = (ratio - prev_ratio) / prev_ratio * 100
					print(f'{symbol} : {ratio} ({ratio_change}%)')
					
					if is_increased:
						alert_message += f"\n  T·ªâ l·ªá Cao/Th·∫•p: üü¢ {ratio:.4f} (+{ratio_change:.2f}%)\n"
						has_significant_increase = True
						previous_ratios[symbol] = current_ratios[symbol]
					else:
						alert_message += f"\n  T·ªâ l·ªá Cao/Th·∫•p: {ratio:.4f}\n"

				alert_message += "------------------------------"
				
				# Th√™m th√¥ng tin ratio v√†o message ƒë·ªÉ d·ªÖ s·∫Øp x·∫øp
				alert_messages.append({
					'message': alert_message, 
					'ratio': ratio
				})

			except ValueError:
				print(f"Error converting data to float for {symbol}")
				continue

		except Exception as e:
			print(f"Error checking {symbol}: {e}")

	# L∆∞u l·∫°i previous_ratios v·ªõi c√°c coin ƒë√£ thay ƒë·ªïi
	save_previous_ratios(previous_ratios)

	# Ch·ªâ l∆∞u v√† g·ª≠i th√¥ng b√°o n·∫øu c√≥ s·ª± thay ƒë·ªïi
	if has_significant_increase and alert_messages:
		# S·∫Øp x·∫øp messages theo ratio gi·∫£m d·∫ßn
		sorted_messages = sorted(alert_messages, key=lambda x: x['ratio'], reverse=True)

		full_alert = f"****** Automatic Telegram Bot Message ******\n"
		full_alert += f"Monitoring data at {datetime.now(utc_tz).strftime('%H:%M - %d.%m.%y')} UTC:\n\n"
		current_message = full_alert
		
		# Th√™m index sau khi s·∫Øp x·∫øp
		for index, item in enumerate(sorted_messages, 1):
			message = f"{index}) " + item['message']
			if len(current_message) + len(message) > 4000:
				bot.send_message(chat_id=USER_CHAT_ID, text=current_message, parse_mode='Markdown')
				current_message = full_alert

			current_message += message + "\n"

		if current_message.strip():
			bot.send_message(chat_id=USER_CHAT_ID, text=current_message, parse_mode='Markdown')

TIME_SET = [5, 'm']

def run_schedule():
	while True:
		now = datetime.now()
		if TIME_SET[1] == 's':
			# G·ª≠i li√™n t·ª•c sau m·ªói kho·∫£ng th·ªùi gian ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a.
			interval_seconds = TIME_SET[0]
			next_run_time = now + timedelta(seconds=interval_seconds)
			wait_time = interval_seconds
		elif TIME_SET[1] == 'm':
			# G·ª≠i ·ªü gi√¢y th·ª© 10 c·ªßa m·ªói b∆∞·ªõc nh·∫£y ph√∫t.
			interval_minutes = TIME_SET[0]
			
			# Calculate the next minute to run
			next_minute = ((now.minute // interval_minutes) + 1) * interval_minutes
			
			# Handle rollover to next hour if needed
			if next_minute >= 60:
				next_minute = next_minute % 60
				next_run_time = (now + timedelta(hours=1)).replace(
					minute=next_minute,
					second=5, 
					microsecond=0
				)
			else:
				next_run_time = now.replace(
					minute=next_minute,
					second=5, 
					microsecond=0
				)
			
			# N·∫øu th·ªùi gian hi·ªán t·∫°i ƒë√£ qua th·ªùi gian t√≠nh to√°n, chuy·ªÉn sang l·∫ßn ti·∫øp theo.
			if now >= next_run_time:
				next_run_time += timedelta(minutes=interval_minutes)
			
			wait_time = (next_run_time - now).total_seconds()

		print(f"ƒê·ª£i {wait_time:.2f} gi√¢y ƒë·∫øn l·∫ßn ch·∫°y ti·∫øp theo l√∫c {next_run_time.strftime('%H:%M:%S')}.")

		time.sleep(wait_time)
		check_coin_limits()

def start_telegram_bot():
	bot_thread = threading.Thread(target=bot.polling)
	bot_thread.start()

def start_schedule():
	schedule_thread = threading.Thread(target=run_schedule)
	schedule_thread.start()

if __name__ == '__main__':
	start_telegram_bot()
	start_schedule()